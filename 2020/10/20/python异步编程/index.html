<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiaobinzhao.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"Valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="什么是异步编程提到异步，那么就有同步。需要了解一下几个名词：同步&#x2F;异步、阻塞&#x2F;非阻塞。">
<meta property="og:type" content="article">
<meta property="og:title" content="python异步编程">
<meta property="og:url" content="https://xiaobinzhao.github.io/2020/10/20/python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="什么是异步编程提到异步，那么就有同步。需要了解一下几个名词：同步&#x2F;异步、阻塞&#x2F;非阻塞。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiaobinzhao.github.io/images/cpu%E6%97%B6%E9%97%B4%E8%A7%82.png">
<meta property="og:image" content="http://c.biancheng.net/uploads/allimg/190830/2-1ZS012105L23.gif">
<meta property="article:published_time" content="2020-10-20T01:49:01.000Z">
<meta property="article:modified_time" content="2022-05-25T06:52:53.081Z">
<meta property="article:author" content="琢灵">
<meta property="article:tag" content="python">
<meta property="article:tag" content="异步编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiaobinzhao.github.io/images/cpu%E6%97%B6%E9%97%B4%E8%A7%82.png">

<link rel="canonical" href="https://xiaobinzhao.github.io/2020/10/20/python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>python异步编程 | 路漫漫其修远兮</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="路漫漫其修远兮" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">路漫漫其修远兮</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">灵自天生，用心雕琢</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobinzhao.github.io/2020/10/20/python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my-avatar.jpg">
      <meta itemprop="name" content="琢灵">
      <meta itemprop="description" content="技术笔记，生活点滴">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python异步编程
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-20 09:49:01" itemprop="dateCreated datePublished" datetime="2020-10-20T09:49:01+08:00">2020-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-25 14:52:53" itemprop="dateModified" datetime="2022-05-25T14:52:53+08:00">2022-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/10/20/python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/10/20/python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="什么是异步编程"><a href="#什么是异步编程" class="headerlink" title="什么是异步编程"></a>什么是异步编程</h1><p>提到异步，那么就有同步。需要了解一下几个名词：同步/异步、阻塞/非阻塞。</p>
<a id="more"></a>

<p>具体解释参看 io模型与阻塞相关章节。</p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><ul>
<li>程序未得到所需计算资源时被挂起的状态。</li>
<li><strong>程序在等待某个操作完成期间，自身无法继续干别的事情，则称该程序在该操作上是阻塞的。</strong></li>
<li>常见的阻塞形式有：网络I/O阻塞、磁盘I/O阻塞、用户输入阻塞等。</li>
</ul>
<p>阻塞是无处不在的，包括CPU切换上下文时，所有的进程都无法真正干事情，它们也会被阻塞。（如果是多核CPU则正在执行上下文切换操作的核不可被利用。）</p>
<h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><ul>
<li><strong>程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事情，则称该程序在该操作上是非阻塞的。</strong></li>
<li>非阻塞并<strong>不是</strong>在任何程序级别、任何情况下都可以存在的。</li>
<li>仅当程序封装的级别可以囊括独立的子程序单元时，它才可能存在非阻塞状态。</li>
</ul>
<p>非阻塞的存在是因为阻塞存在，正因为某个操作阻塞导致的耗时与效率低下，我们才要把它变成非阻塞的。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li>并发描述的是程序的组织结构。指程序要被设计成多个可独立执行的子任务。</li>
<li>以利用有限的计算机资源使多个任务可以被实时或近实时执行为目的。</li>
</ul>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><ul>
<li>并行描述的是程序的执行状态。指多个任务同时被执行。</li>
<li>以利用富余计算资源（多核CPU）加速完成多个任务为目的。</li>
<li>并发提供了一种程序组织结构方式，让问题的解决方案可以并行执行，但并行执行不是必须的。</li>
</ul>
<h2 id="概念总结"><a href="#概念总结" class="headerlink" title="概念总结"></a>概念总结</h2><ul>
<li>并行是为了利用多核加速多任务完成的进度</li>
<li>并发是为了让独立的子任务都有机会被尽快执行，但不一定能加速整体进度</li>
<li>非阻塞是为了提高程序整体执行效率</li>
<li>异步是高效地组织非阻塞任务的方式</li>
</ul>
<p>要支持并发，必须拆分为多任务，不同任务相对而言才有阻塞/非阻塞、同步/异步。所以，并发、异步、非阻塞三个词总是如影随形。</p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><p>以进程、线程、协程、函数/方法作为执行任务程序的基本单位，结合回调、事件循环、信号量等机制，以提高程序整体执行效率和并发能力的编程方式。</p>
<p>如果在某程序的运行时，能根据已经执行的指令准确判断它接下来要进行哪个具体操作，那它是同步程序，反之则为异步程序。（无序与有序的区别）</p>
<p>同步/异步、阻塞/非阻塞并非水火不容，要看讨论的程序所处的封装级别。例如购物程序在处理多个用户的浏览请求可以是异步的，而更新库存时必须是同步的。</p>
<h2 id="异步之难-nan"><a href="#异步之难-nan" class="headerlink" title="异步之难(nán)"></a>异步之难(nán)</h2><p>控制不住“计几”写的程序，因为其执行顺序不可预料，当下正要发生什么事件不可预料。在并行情况下更为复杂和艰难。</p>
<p>所以，几乎所有的异步框架都将异步编程模型简化：一次只允许处理一个事件。故而有关异步的讨论几乎都集中在了单线程内。</p>
<p>如果某事件处理程序需要长时间执行，所有其他部分都会被阻塞。</p>
<p>所以，一旦采取异步编程，每个异步调用必须“足够小”，不能耗时太久。如何拆分异步任务成了难题。</p>
<p>程序下一步行为往往依赖上一步执行结果，如何知晓上次异步调用已完成并获取结果？</p>
<p><strong>回调（Callback）成了必然选择</strong>。那又需要面临“回调地狱”的折磨。</p>
<p>同步代码改为异步代码，必然破坏代码结构。</p>
<p>解决问题的逻辑也要转变，不再是一条路走到黑，需要精心安排异步任务。</p>
<h1 id="为什么要异步编程"><a href="#为什么要异步编程" class="headerlink" title="为什么要异步编程"></a>为什么要异步编程</h1><p>如上文所述，异步编程面临诸多难点，Python 之父亲自上阵打磨4年才使 asyncio 模块在Python 3.6中“转正”，如此苦心为什么？答案只有一个：它值得！下面我们看看为何而值得。</p>
<h2 id="CPU的时间观"><a href="#CPU的时间观" class="headerlink" title="CPU的时间观"></a>CPU的时间观</h2><p><img src="/images/cpu%E6%97%B6%E9%97%B4%E8%A7%82.png" alt="cpu时间观"></p>
<p>我们将一个 2.6GHz 的 CPU 拟人化，假设它执行一条命令的时间，他它感觉上过了一秒钟。CPU是计算机的处理核心，也是最宝贵的资源，如果有浪费CPU的运行时间，导致其利用率不足，那程序效率必然低下（因为实际上有资源可以使效率更高）。</p>
<p>如上图所示，在千兆网上传输2KB数据，CPU感觉过了14个小时，如果是在10M的公网上呢？那效率会低百倍！如果在这么长的一段时间内，CPU只是傻等结果而不能去干其他事情，是不是在浪费CPU的青春？</p>
<p>鲁迅说，浪费“CPU”的时间等于谋财害命。而凶手就是程序猿。</p>
<h2 id="面临的问题"><a href="#面临的问题" class="headerlink" title="面临的问题"></a>面临的问题</h2><ul>
<li>成本问题</li>
</ul>
<blockquote>
<p>如果一个程序不能有效利用一台计算机资源，那必然需要更多的计算机通过运行更多的程序实例来弥补需求缺口。例如我前不久主导重写的项目，使用Python异步编程，改版后由原来的7台服务器削减至3台，成本骤降57%。一台AWS m4.xlarge 型通用服务器按需付费实例一年价格约 1.2 万人民币。</p>
</blockquote>
<ul>
<li><p>效率问题</p>
<blockquote>
<p>如果不在乎钱的消耗，那也会在意效率问题。当服务器数量堆叠到一定规模后，如果不改进软件架构和实现，加机器是徒劳，而且运维成本会骤然增加。比如别人家的电商平台支持6000单/秒支付，而自家在下单量才支撑2000单/秒，在双十一这种活动的时候，钱送上门也赚不到。</p>
</blockquote>
</li>
<li><p>C10k/C10M挑战</p>
<blockquote>
<p>C10k（concurrently handling 10k connections）是一个在1999年被提出来的技术挑战，如何在一颗1GHz CPU，2G内存，1gbps网络环境下，让单台服务器同时为1万个客户端提供FTP服务。而到了2010年后，随着硬件技术的发展，这个问题被延伸为C10M，即如何利用8核心CPU，64G内存，在10gbps的网络上保持1000万并发连接，或是每秒钟处理100万的连接。（两种类型的计算机资源在各自的时代都约为1200美元）</p>
</blockquote>
</li>
</ul>
<p>成本和效率问题是从企业经营角度讲，C10k/C10M问题则是从技术角度出发挑战软硬件极限。C10k/C10M 问题得解，成本问题和效率问题迎刃而解。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>《约束理论与企业优化》中指出：“除了瓶颈之外，任何改进都是幻觉。”</p>
<p>CPU告诉我们，它自己很快，而上下文切换慢、内存读数据慢、磁盘寻址与取数据慢、网络传输慢……总之，离开CPU 后的一切，除了一级高速缓存，都很慢。我们观察计算机的组成可以知道，主要由运算器、控制器、存储器、输入设备、输出设备五部分组成。运算器和控制器主要集成在CPU中，除此之外全是I/O，包括读写内存、读写磁盘、读写网卡全都是I/O。<strong>I/O成了最大的瓶颈</strong>。</p>
<p>异步程序可以提高效率，而最大的瓶颈在I/O，业界诞生的解决方案没出意料：<strong>异步I/O吧，异步I/O吧，异步I/O吧吧！</strong></p>
<h1 id="python怎么做异步编程"><a href="#python怎么做异步编程" class="headerlink" title="python怎么做异步编程"></a>python怎么做异步编程</h1><p>如今，地球上最发达、规模最庞大的计算机程序，莫过于因特网。而从CPU的时间观中可知，网络I/O是最大的I/O瓶颈，除了宕机没有比它更慢的。所以，诸多异步框架都对准的是<strong>网络I/O</strong>。</p>
<h2 id="异步进化之路"><a href="#异步进化之路" class="headerlink" title="异步进化之路"></a>异步进化之路</h2><p>那么异步只是怎么逐步由同步进化而来呢？我们从一个爬虫例子说起，从因特网上下载10篇网页。</p>
<h3 id="同步阻塞方式"><a href="#同步阻塞方式" class="headerlink" title="同步阻塞方式"></a>同步阻塞方式</h3><p>最容易想到的解决方案就是依次下载，从建立socket连接到发送网络请求再到读取响应数据，顺序进行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocking_way</span>():</span></span><br><span class="line">    sock = socket.socket()</span><br><span class="line">    <span class="comment"># blocking</span></span><br><span class="line">    sock.connect((<span class="string">&#x27;example.com&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">    request = <span class="string">&#x27;GET / HTTP/1.0\r\nHost: example.com\r\n\r\n&#x27;</span></span><br><span class="line">    sock.send(request.encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">    response = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    chunk = sock.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">while</span> chunk:</span><br><span class="line">        response += chunk</span><br><span class="line">        <span class="comment"># blocking</span></span><br><span class="line">        chunk = sock.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync_way</span>():</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        res.append(blocking_way())</span><br><span class="line">    <span class="keyword">return</span> len(res)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：总体耗时约为4.5秒。（因网络波动每次测试结果有所变动，本文取多次平均值）</p>
</blockquote>
<p>创建网络连接，多久能创建完成不是客户端决定的，而是由网络状况和服务端处理能力共同决定。服务端什么时候返回了响应数据并被客户端接收到可供程序读取，也是不可预测的。所以sock.connect()和sock.recv()这两个调用在默认情况下是阻塞的。</p>
<blockquote>
<p>注：sock.send()函数并不会阻塞太久，它只负责将请求数据拷贝到TCP/IP协议栈的系统缓冲区中就返回，并不等待服务端返回的应答确认。</p>
</blockquote>
<p>上面说了很多，我们力图说明一件事：<strong>同步阻塞的网络交互方式，效率低十分低下</strong>。特别是在网络交互频繁的程序中。这种方式根本不可能挑战C10K/C10M。</p>
<h3 id="改进方式：多进程"><a href="#改进方式：多进程" class="headerlink" title="改进方式：多进程"></a>改进方式：多进程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocking_way</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;与同步代码相同，此处省略&#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_way</span>():</span></span><br><span class="line">    workers = <span class="number">10</span></span><br><span class="line">    <span class="keyword">with</span> futures.ProcessPoolExecutor(worksers) <span class="keyword">as</span> executor:</span><br><span class="line">        futs = &#123;executor.submit(blocking_way) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)&#125;</span><br><span class="line">    <span class="keyword">return</span> len([fut.result() <span class="keyword">for</span> fut <span class="keyword">in</span> futs])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：总体耗时约为 0.6 秒</p>
</blockquote>
<p>改善效果立竿见影。但仍然有问题。总体耗时并没有缩减到原来的十分之一，而是九分之一左右，还有一些时间耗到哪里去了？进程切换开销。</p>
<p>进程切换开销不止像“CPU的时间观”所列的“上下文切换”那么低。CPU从一个进程切换到另一个进程，需要把旧进程运行时的寄存器状态、内存状态全部保存好，再将另一个进程之前保存的数据恢复。对CPU来讲，几个小时就干等着。当进程数量大于CPU核心数量时，进程切换是必然需要的。</p>
<p>除了切换开销，多进程还有另外的缺点。一般的服务器在能够稳定运行的前提下，可以同时处理的进程数在数十个到数百个规模。如果进程数量规模更大，系统运行将不稳定，而且可用内存资源往往也会不足。</p>
<p>多进程解决方案在面临每天需要成百上千万次下载任务的爬虫系统，或者需要同时搞定数万并发的电商系统来说，并不适合。</p>
<p>除了切换开销大，以及可支持的任务规模小之外，多进程还有其他缺点，如状态共享等</p>
<h3 id="继续改进：多线程"><a href="#继续改进：多线程" class="headerlink" title="继续改进：多线程"></a>继续改进：多线程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">blocking_way</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;与同步代码相同，此处省略&#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thread_way</span>():</span></span><br><span class="line">    workers = <span class="number">10</span></span><br><span class="line">    <span class="keyword">with</span> futures.ThreadPoolExecutor(workers) <span class="keyword">as</span> executor:</span><br><span class="line">        futs = &#123;executor.submit(blocking_way) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)&#125;</span><br><span class="line">    <span class="keyword">return</span> len([fut.result() <span class="keyword">for</span> fut <span class="keyword">in</span> futs])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：总体运行时间约0.43秒。</p>
</blockquote>
<p>结果符合预期，比多进程耗时要少些。从运行时间上看，多线程似乎已经解决了切换开销大的问题。而且可支持的任务数量规模，也变成了数百个到数千个。</p>
<p>但是，多线程仍有问题，特别是Python里的多线程。首先，Python中的多线程因为GIL的存在，它们并不能利用CPU多核优势，一个Python进程中，只允许有一个线程处于运行状态。那为什么结果还是如预期，耗时缩减到了十分之一？</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190830/2-1ZS012105L23.gif" alt="GIL工作流程示意图"></p>
<p>因为在做阻塞的系统调用时，例如sock.connect(),sock.recv()时，当前线程会释放GIL，让别的线程有执行机会。但是单个线程内，在阻塞调用上还是阻塞的。</p>
<p>除了GIL之外，所有的多线程还有通病。它们是被OS调度，调度策略是抢占式的，以保证同等优先级的线程都有均等的执行机会，那带来的问题是：并不知道下一时刻是哪个线程被运行，也不知道它正要执行的代码是什么。所以就可能存在<strong>竞态条件</strong>。</p>
<p>例如爬虫工作线程从任务队列拿待抓取URL的时候，如果多个爬虫线程同时来取，那这个任务到底该给谁？那就需要用到“锁”或“同步队列”来保证下载任务不会被重复执行。</p>
<p>而且线程支持的多任务规模，在数百到数千的数量规模。在大规模的高频网络交互系统中，仍然有些吃力。当然，多线程最主要的问题还是<strong>竞态条件</strong>。</p>
<h3 id="非阻塞方式"><a href="#非阻塞方式" class="headerlink" title="非阻塞方式"></a>非阻塞方式</h3><p>终于，我们来到了非阻塞解决方案。先来看看最原始的非阻塞如何工作的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def nonblocking_way():</span><br><span class="line">    sock &#x3D; socket.socket()</span><br><span class="line">    sock.setblocking(False)</span><br><span class="line">    try:</span><br><span class="line">        sock.connect((&#39;example.com&#39;, 80))</span><br><span class="line">    except BlockingIOError:</span><br><span class="line">        # 非阻塞连接过程中也会抛出异常</span><br><span class="line">        pass</span><br><span class="line">    request &#x3D; &#39;GET &#x2F; HTTP&#x2F;1.0\r\nHost: example.com\r\n\r\n&#39;</span><br><span class="line">    data &#x3D; request.encode(&#39;ascii&#39;)</span><br><span class="line">    # 不知道socket何时就绪，所以不断尝试发送</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            sock.send(data)</span><br><span class="line">            # 直到send不抛异常，则发送完成</span><br><span class="line">            break</span><br><span class="line">        except OSError:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line">    response &#x3D; b&#39;&#39;</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            chunk &#x3D; sock.recv(4096)</span><br><span class="line">            while chunk:</span><br><span class="line">                response +&#x3D; chunk</span><br><span class="line">                chunk &#x3D; sock.recv(4096)</span><br><span class="line">            break</span><br><span class="line">        except OSError:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line">    return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sync_way():</span><br><span class="line">    res &#x3D; []</span><br><span class="line">    for i in range(10):</span><br><span class="line">        res.append(nonblocking_way())</span><br><span class="line">    return len(res)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：总体耗时约4.3秒。</p>
</blockquote>
<p>首先注意到两点，就感觉被骗了。一是耗时与同步阻塞相当，二是代码更复杂。要非阻塞何用？且慢。</p>
<p>上图代码<code>sock.setblocking(False)</code>告诉OS，让socket上阻塞调用都改为非阻塞的方式。之前我们说到，非阻塞就是在做一件事的时候，不阻碍调用它的程序做别的事情。上述代码在执行完 sock.connect() 和 sock.recv()后的确不再阻塞，可以继续往下执行请求准备的代码或者是执行下一次读取。</p>
<p>代码变得更复杂也是上述原因所致。第11行要放在try语句内，是因为socket在发送非阻塞连接请求过程中，系统底层也会抛出异常。connect()被调用之后，立即可以往下执行第15和16行的代码。</p>
<p>需要while循环不断尝试send()，是因为connect()已经非阻塞，在send()之时并不知道 socket 的连接是否就绪，只有不断尝试，尝试成功为止，即发送数据成功了。recv()调用也是同理。</p>
<p>虽然 connect() 和 recv()不再阻塞主程序，空出来的时间段CPU没有空闲着，但并没有利用好这空闲去做其他有意义的事情，而是在循环尝试读写 socket（不停判断非阻塞调用的状态是否就绪）。还得处理来自底层的可忽略的异常。也不能同时处理多个 socket 。</p>
<p>然后10次下载任务仍然按序进行。所以总体执行时间和同步阻塞相当。如果非得这样子，那还不如同步阻塞算了。</p>
<h3 id="非阻塞改进"><a href="#非阻塞改进" class="headerlink" title="非阻塞改进"></a>非阻塞改进</h3><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p><strong>判断非阻塞调用是否就绪如果 OS能做</strong>，是不是应用程序就可以不用自己去等待和判断了，就可以利用这个空闲去做其他事情以提高效率。</p>
<p>所以OS将I/O状态的变化都封装成了事件，如可读事件、可写事件。并且提供了专门的系统模块让应用程序可以接收事件通知。这个模块就是select。让应用程序可以通过select注册文件描述符和回调函数。当文件描述符的状态发生变化时，select就调用事先注册的回调函数。</p>
<p>select因其算法效率比较低，后来改进成了poll，再后来又有进一步改进，BSD内核改进成了kqueue模块，而Linux内核改进成了epoll模块。这四个模块的作用都相同，暴露给程序员使用的API也几乎一致，区别在于kqueue 和 epoll在处理大量文件描述符时效率更高。</p>
<p>鉴于 Linux 服务器的普遍性，以及为了追求更高效率，所以我们常常听闻被探讨的模块都是 epoll 。</p>
<p>关于io多路复用（select/poll/epoll）请参看 io 模型章节。</p>
<h4 id="回调-Callback"><a href="#回调-Callback" class="headerlink" title="回调(Callback)"></a>回调(Callback)</h4><p>把I/O事件的等待和监听任务交给了 OS，那 OS在知道I/O状态发生改变后（例如socket连接已建立成功可发送数据），它又怎么知道接下来该干嘛呢？只能回调。</p>
<p>需要我们将发送数据与读取数据封装成独立的函数，让epoll代替应用程序监听socket状态时，得告诉epoll：“如果socket状态变为可以往里写数据（连接建立成功了），请调用HTTP请求发送函数。如果socket变为可以读数据了（客户端已收到响应），请调用响应处理函数。”</p>
<p>于是我们利用epoll结合回调机制重构爬虫代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">from selectors import DefaultSelector, EVENT_WRITE, EVENT_READ</span><br><span class="line"></span><br><span class="line">selector &#x3D; DefaultSelector()</span><br><span class="line">stopped &#x3D; False</span><br><span class="line">urls_todo &#x3D; &#123;&#39;&#x2F;&#39;, &#39;&#x2F;1&#39;, &#39;&#x2F;2&#39;, &#39;&#x2F;3&#39;, &#39;&#x2F;4&#39;, &#39;&#x2F;5&#39;, &#39;&#x2F;6&#39;, &#39;&#x2F;7&#39;, &#39;&#x2F;8&#39;, &#39;&#x2F;9&#39;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Crawler:</span><br><span class="line">    def __init__(self, url):</span><br><span class="line">        self.url &#x3D; url</span><br><span class="line">        self.sock &#x3D; None</span><br><span class="line">        self.response &#x3D; b&#39;&#39;</span><br><span class="line"></span><br><span class="line">    def fetch(self):</span><br><span class="line">        self.sock &#x3D; socket.socket()</span><br><span class="line">        self.sock.setblocking(False)</span><br><span class="line">        try:</span><br><span class="line">            self.sock.connect((&#39;example.com&#39;, 80))</span><br><span class="line">        except BlockingIOError:</span><br><span class="line">            pass</span><br><span class="line">        selector.register(self.sock.fileno(), EVENT_WRITE, self.connected)</span><br><span class="line"></span><br><span class="line">    def connected(self, key, mask):</span><br><span class="line">        selector.unregister(key.fd)</span><br><span class="line">        get &#x3D; &#39;GET &#123;0&#125; HTTP&#x2F;1.0\r\nHost: example.com\r\n\r\n&#39;.format(self.url)</span><br><span class="line">        self.sock.send(get.encode(&#39;ascii&#39;))</span><br><span class="line">        selector.register(key.fd, EVENT_READ, self.read_response)</span><br><span class="line"></span><br><span class="line">    def read_response(self, key, mask):</span><br><span class="line">        global stopped</span><br><span class="line">        # 如果响应大于4KB，下一次循环会继续读</span><br><span class="line">        chunk &#x3D; self.sock.recv(4096)</span><br><span class="line">        if chunk:</span><br><span class="line">            self.response +&#x3D; chunk</span><br><span class="line">        else:</span><br><span class="line">            selector.unregister(key.fd)</span><br><span class="line">            urls_todo.remove(self.url)</span><br><span class="line">            if not urls_todo:</span><br><span class="line">                stopped &#x3D; True</span><br><span class="line">def loop():</span><br><span class="line">    while not stopped:</span><br><span class="line">        # 阻塞, 直到一个事件发生</span><br><span class="line">        events &#x3D; selector.select()</span><br><span class="line">        for event_key, event_mask in events:</span><br><span class="line">            callback &#x3D; event_key.data</span><br><span class="line">            callback(event_key, event_mask)</span><br></pre></td></tr></table></figure>
<p>此处和前面稍有不同的是，我们将下载不同的10个页面，相对URL路径存放于urls_todo集合中。现在看看改进在哪。</p>
<p>首先，不断尝试send() 和 recv() 的两个循环被消灭掉了。</p>
<p>其次，导入了selectors模块，并创建了一个DefaultSelector实例。Python标准库提供的selectors模块是对底层select/poll/epoll/kqueue的封装。DefaultSelector类会根据 OS 环境自动选择最佳的模块，那在 Linux 2.5.44 及更新的版本上都是epoll了。</p>
<p>然后，在第25行和第31行分别注册了socket可写事件(EVENT_WRITE)和可读事件(EVENT_READ)发生后应该采取的回调函数。</p>
<p>虽然代码结构清晰了，阻塞操作也交给OS去等待和通知了，但是，我们要抓取10个不同页面，就得创建10个Crawler实例，就有20个事件将要发生，那如何从selector里获取当前正发生的事件，并且得到对应的回调函数去执行呢？</p>
<h4 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h4><p>为了解决上述问题，那我们只得采用老办法，写一个循环，去访问selector模块，等待它告诉我们当前是哪个事件发生了，应该对应哪个回调。这个等待事件通知的循环，称之为事件循环。</p>
<p>上述代码中，我们用stopped全局变量控制事件循环何时停止。当urls_todo消耗完毕后，会标记stopped为True。</p>
<p>重要的是第44行代码，selector.select() 是一个阻塞调用，因为如果事件不发生，那应用程序就没事件可处理，所以就干脆阻塞在这里等待事件发生。那可以推断，如果只下载一篇网页，一定要connect()之后才能send()继而recv()，那它的效率和阻塞的方式是一样的。因为不在connect()/recv()上阻塞，也得在select()上阻塞。</p>
<p>所以，selector机制(后文以此称呼代指epoll/kqueue)是设计用来解决大量并发连接的。当系统中有大量非阻塞调用，能随时产生事件的时候，selector机制才能发挥最大的威力。</p>
<p>下面是如何启创建10个下载任务和启动事件循环的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    import time</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    for url in urls_todo:</span><br><span class="line">        crawler &#x3D; Crawler(url)</span><br><span class="line">        crawler.fetch()</span><br><span class="line">    loop()</span><br><span class="line">    print(time.time() - start)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：总体耗时约0.45秒。</p>
</blockquote>
<p>上述执行结果令人振奋。在单线程内用 事件循环+回调搞定了10篇网页同时下载的问题。这，已经是异步编程了。虽然有一个for 循环顺序地创建Crawler 实例并调用 fetch 方法，但是fetch内仅有connect()和注册可写事件，而且从执行时间明显可以推断，多个下载任务确实在同时进行！</p>
<p>上述代码异步执行的过程：</p>
<ol>
<li>创建Crawler 实例；</li>
<li>调用fetch方法，会创建socket连接和在selector上注册可写事件；</li>
<li>fetch内并无阻塞操作，该方法立即返回；</li>
<li>重复上述3个步骤，将10个不同的下载任务都加入事件循环；</li>
<li>启动事件循环，进入第1轮循环，阻塞在事件监听上；</li>
<li>当某个下载任务EVENT_WRITE被触发，回调其connected方法，第一轮事件循环结束；</li>
<li>进入第2轮事件循环，当某个下载任务有事件触发，执行其回调函数；此时已经不能推测是哪个事件发生，因为有可能是上次connected里的EVENT_READ先被触发，也可能是其他某个任务的EVENT_WRITE被触发；（此时，原来在一个下载任务上会阻塞的那段时间被利用起来执行另一个下载任务了）</li>
<li>循环往复，直至所有下载任务被处理完成</li>
<li>退出事件循环，结束整个下载程序</li>
</ol>
<h4 id="非阻塞总结"><a href="#非阻塞总结" class="headerlink" title="非阻塞总结"></a>非阻塞总结</h4><p>目前为止，我们已经从同步阻塞学习到了异步非阻塞。掌握了在单线程内同时并发执行多个网络I/O阻塞型任务的黑魔法。而且与多线程相比，连线程切换都没有了，执行回调函数是函数调用开销，在线程的栈内完成，因此性能也更好，单机支持的任务规模也变成了数万到数十万个。（不过我们知道：没有免费午餐，也没有银弹。）</p>
<p>部分编程语言中，对异步编程的支持就止步于此（不含语言官方之外的扩展）。需要程序猿直接使用epoll去注册事件和回调、维护一个事件循环，然后大多数时间都花在设计回调函数上。</p>
<p>通过本节的学习，我们应该认识到，不论什么编程语言，但凡要做异步编程，上述的“<strong>事件循环+回调</strong>”这种模式是逃不掉的，尽管它可能用的不是epoll，也可能不是while循环。如果你找到了一种不属于 “等会儿告诉你”模型的异步方式，请立即给我打电话（注意，打电话是Call）。</p>
<p>为什么我们在某些异步编程中并没有看到 CallBack 模式呢？这就是我们接下来要探讨的问题。本节是学习异步编程的一个终点，也是另一个起点。毕竟咱们讲 Python 异步编程，还没提到其主角协程的用武之地。</p>
<h2 id="python的异步实现"><a href="#python的异步实现" class="headerlink" title="python的异步实现"></a>python的异步实现</h2><p>我们将在本节学习到 Python生态对异步编程的支持是如何继承前文所述的“事件循环+回调”模式演变到asyncio的原生协程模式。</p>
<h3 id="回调之痛，以终为始"><a href="#回调之痛，以终为始" class="headerlink" title="回调之痛，以终为始"></a>回调之痛，以终为始</h3><p>在上节中，我们已经学会了“事件循环+回调”的基本运行原理，可以基于这种方式在单线程内实现异步编程。也确实能够大大提高程序运行效率。但是，刚才所学的只是最基本的，然而在生产项目中，要应对的复杂度会大大增加。考虑如下问题：</p>
<ol>
<li>如果回调函数执行不正常该如何？</li>
<li>如果回调里面还要嵌套回调怎么办？要嵌套很多层怎么办？</li>
<li>如果嵌套了多层，其中某个环节出错了会造成什么后果？</li>
<li>如果有个数据需要被每个回调都处理怎么办？</li>
<li>……</li>
</ol>
<p>在实际编程中，上述系列问题不可避免。在这些问题的背后隐藏着回调编程模式的一些</p>
<p>缺点：</p>
<ul>
<li>回调地狱</li>
<li>破坏代码结构<br>写同步代码时，关联的操作时自上而下运行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">do_a()</span><br><span class="line">do_b()</span><br></pre></td></tr></table></figure>
如果 b 处理依赖于 a 处理的结果，而 a 过程是异步调用，就不知 a何时能返回值，需要将后续的处理过程以callback的方式传递给 a ，让 a执行完以后可以执行 b。代码变化为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_a(do_b())</span><br></pre></td></tr></table></figure>
如果整个流程中全部改为异步处理，而流程比较长的话，代码逻辑就会成为这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do_a(do_b(do_c(do_d(do_e(do_f(......))))))</span><br></pre></td></tr></table></figure>
上面实际也是回调地狱式的风格，但这不是主要矛盾。主要在于，原本从上而下的代码结构，要改成从内到外的。先f，再e，再d，…，直到最外层 a 执行完成。在同步版本中，执行完a后执行b，这是线程的指令指针控制着的流程，而在回调版本中，流程就是程序猿需要注意和安排的。</li>
<li>共享状态管理困难<br>回顾同步阻塞版的爬虫代码，sock对象从头使用到尾，而在回调的版本中，我们必须在Crawler实例化后的对象self里保存它自己的sock对象。如果不是采用OOP的编程风格，那需要把要共享的状态接力似的传递给每一个回调。多个异步调用之间，到底要共享哪些状态，事先就得考虑清楚，精心设计。</li>
<li>错误处理困难<br>一连串的回调构成一个完整的调用链。例如上述的 a 到 f。假如 d抛了异常怎么办？整个调用链断掉，接力传递的状态也会丢失，这种现象称为调用栈撕裂。 c 不知道该干嘛，继续异常，然后是 b 异常，接着 a异常。好嘛，报错日志就告诉你，a 调用出错了，但实际是 d出错。所以，为了防止栈撕裂，异常必须以数据的形式返回，而不是直接抛出异常，然后每个回调中需要检查上次调用的返回值，以防错误吞没。</li>
</ul>
<p>如果说代码风格难看是小事，但栈撕裂和状态管理困难这两个缺点会让基于回调的异步编程很艰难。所以不同编程语言的生态都在致力于解决这个问题。才诞生了后来的Promise、Co-routine等解决方案。</p>
<p>Python 生态也以终为始，秉承着“程序猿不必难程序猿”的原则，让语言和框架开发者苦逼一点，也要让应用开发者舒坦。在事件循环+回调的基础上衍生出了基于协程的解决方案，代表作有 Tornado、Twisted、asyncio 等。接下来我们随着 Python 生态异步编程的发展过程，深入理解Python异步编程。</p>
<h1 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h1><p>通过前面的学习，我们清楚地认识到异步编程最大的困难：异步任务何时执行完毕？接下来要对异步调用的返回结果做什么操作？</p>
<p>上述问题我们已经通过事件循环和回调解决了。但是回调会让程序变得复杂。要异步，必回调，又是否有办法规避其缺点呢？那需要弄清楚其本质，为什么回调是必须的？还有使用回调时克服的那些缺点又是为了什么？</p>
<p>答案是程序为了知道自己已经干了什么？正在干什么？将来要干什么？换言之，程序得知道当前所处的状态，而且要将这个状态在不同的回调之间延续下去。</p>
<p>多个回调之间的状态管理困难，那让每个回调都能管理自己的状态怎么样？链式调用会有栈撕裂的困难，让回调之间不再链式调用怎样？不链式调用的话，那又如何让被调用者知道已经完成了？那就让这个回调通知那个回调如何？而且一个回调，不就是一个待处理任务吗？</p>
<p>任务之间得相互通知，每个任务得有自己的状态。那不就是很古老的编程技法：协作式多任务？然而要在单线程内做调度，啊哈，协程！每个协程具有自己的栈帧，当然能知道自己处于什么状态，协程之间可以协作那自然可以通知别的协程。</p>
<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程(Co-routine)，即是协作式的例程。</p>
<p>它是非抢占式的多任务子例程的概括，可以允许有多个入口点在例程中确定的位置来控制程序的暂停与恢复执行。</p>
<p>例程是什么？编程语言定义的可被调用的代码段，为了完成某个特定功能而封装在一起的一系列指令。一般的编程语言都用称为函数或方法的代码结构来体现。</p>
<h2 id="基于生成器的协程（yield）"><a href="#基于生成器的协程（yield）" class="headerlink" title="基于生成器的协程（yield）"></a>基于生成器的协程（yield）</h2><p>早期的 Pythoner 发现Python中有种特殊的对象——生成器（Generator），它的特点和协程很像。每一次迭代之间，会暂停执行，继续下一次迭代的时候还不会丢失先前的状态。</p>
<p>为了支持用生成器做简单的协程，Python2.5对生成器进行了增强(PEP342)，该增强提案的标题是 “Coroutines via EnhancedGenerators”。有了PEP342的加持，生成器可以通过yield暂停执行和向外返回数据，也可以通过send()向生成器内发送数据，还可以通过throw()向生成器内抛出异常以便随时终止生成器的运行。</p>
<p>yiled 具体解释参看 yield章节。</p>
<h3 id="未来对象-Future"><a href="#未来对象-Future" class="headerlink" title="未来对象(Future)"></a>未来对象(Future)</h3><p>不用回调的方式了，怎么知道异步调用的结果呢？先设计一个对象，异步调用执行完的时候，就把结果放在它里面。这种对象称之为未来对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = <span class="literal">None</span></span><br><span class="line">        self._callbacks = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_done_callback</span>(<span class="params">self, fn</span>):</span></span><br><span class="line">        self._callbacks.append(fn)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span>(<span class="params">self, result</span>):</span></span><br><span class="line">        self.result = result</span><br><span class="line">        <span class="keyword">for</span> fn <span class="keyword">in</span> self._callbacks:</span><br><span class="line">            fn(self)</span><br></pre></td></tr></table></figure>

<p>未来对象有一个<code>result</code>属性，用于存放未来的执行结果。还有个<code>set_result()</code>方法，是用于设置<code>result</code>的，并且会在给<code>result</code>绑定值以后运行事先给<code>future</code>添加的回调。回调是通过未来对象的<code>add_done_callback()</code>方法添加的。</p>
<p>不要疑惑此处的<code>callback</code>，说好了不回调的嘛？难道忘了我们曾经说的<strong>要异步，必回调</strong>。不过也别急，此处的回调，和先前学到的回调，还真有点不一样。</p>
<h3 id="重构-Crawler"><a href="#重构-Crawler" class="headerlink" title="重构 Crawler"></a>重构 Crawler</h3><p>现在不论如何，我们有了未来对象可以代表未来的值。先用<code>Future</code>来重构爬虫代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.response = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">self</span>):</span></span><br><span class="line">        sock = socket.socket()</span><br><span class="line">        sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sock.connect((<span class="string">&#x27;example.com&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        f = Future()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">on_connected</span>():</span></span><br><span class="line">            f.set_result(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        selector.register(sock.fileno(), EVENT_WRITE, on_connected)</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">        selector.unregister(sock.fileno())</span><br><span class="line">        get = <span class="string">&#x27;GET &#123;0&#125; HTTP/1.0\r\nHost: example.com\r\n\r\n&#x27;</span>.format(self.url)</span><br><span class="line">        sock.send(get.encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">global</span> stopped</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            f = Future()</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">on_readable</span>():</span></span><br><span class="line">                f.set_result(sock.recv(<span class="number">4096</span>))</span><br><span class="line"></span><br><span class="line">            selector.register(sock.fileno(), EVENT_READ, on_readable)</span><br><span class="line">            chunk = <span class="keyword">yield</span> f</span><br><span class="line">            selector.unregister(sock.fileno())</span><br><span class="line">            <span class="keyword">if</span> chunk:</span><br><span class="line">                self.response += chunk</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                urls_todo.remove(self.url)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> urls_todo:</span><br><span class="line">                    stopped = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>和先前的回调版本对比，已经有了较大差异。<code>fetch</code> 方法内有了<code>yield</code>表达式，使它成为了生成器。我们知道生成器需要先调用<code>next()</code>迭代一次或者是先<code>send(None)</code>启动，遇到<code>yield</code>之后便暂停。那这<code>fetch</code>生成器如何再次恢复执行呢？至少 <code>Future</code> 和 <code>Crawler</code>都没看到相关代码。</p>
<h3 id="任务对象-Task"><a href="#任务对象-Task" class="headerlink" title="任务对象(Task)"></a>任务对象(Task)</h3><p>为了解决上述问题，我们只需遵循一个编程规则：<strong>单一职责</strong>，每种角色各司其职，如果还有工作没有角色来做，那就创建一个角色去做。没人来恢复这个生成器的执行么？没人来管理生成器的状态么？创建一个，就叫<code>Task</code>好了，很合适的名字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, coro</span>):</span></span><br><span class="line">        self.coro = coro</span><br><span class="line">        f = Future()</span><br><span class="line">        f.set_result(<span class="literal">None</span>)</span><br><span class="line">        self.step(f)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">self, future</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># send会进入到coro执行, 即fetch, 直到下次yield</span></span><br><span class="line">            <span class="comment"># next_future 为yield返回的对象</span></span><br><span class="line">            next_future = self.coro.send(future.result)</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        next_future.add_done_callback(self.step)</span><br></pre></td></tr></table></figure>

<p>上述代码中Task封装了<code>coro</code>对象，即初始化时传递给他的对象，被管理的任务是待执行的协程，故而这里的<code>coro</code>就是<code>fetch()</code>生成器。它还有个<code>step()</code>方法，在初始化的时候就会执行一遍。<code>step()</code>内会调用生成器的<code>send()</code>方法，初始化第一次发送的是<code>None</code>就驱动了<code>coro</code>即<code>fetch()</code>的第一次执行。</p>
<p><code>send()</code>完成之后，得到下一次的<code>future</code>，然后给下一次的<code>future</code>添加<code>step()</code>回调。原来<code>add_done_callback()</code>不是给写爬虫业务逻辑用的。此前的<code>callback</code>可就干的是业务逻辑呀。</p>
<p>再看<code>fetch()</code>生成器，其内部写完了所有的业务逻辑，包括如何发送请求，如何读取响应。而且注册给<code>selector</code>的回调相当简单，就是给对应的<code>future</code>对象绑定结果值。两个<code>yield</code>表达式都是返回对应的<code>future</code>对象，然后返回<code>Task.step()</code>之内，这样<code>Task</code>, <code>Future</code>, <code>Coroutine</code>三者精妙地串联在了一起。</p>
<p>初始化<code>Task</code>对象以后，把<code>fetch()</code>给驱动到了<code>selector.register(sock.fileno(), EVENT_WRITE, on_connected)</code>之后的<code>yied f</code>就完事了，接下来怎么继续？</p>
<h3 id="事件循环-Event-Loop-驱动协程运行"><a href="#事件循环-Event-Loop-驱动协程运行" class="headerlink" title="事件循环(Event Loop)驱动协程运行"></a>事件循环(Event Loop)驱动协程运行</h3><p>该事件循环上场了。接下来，只需等待已经注册的<code>EVENT_WRITE</code>事件发生。事件循环就像心脏一般，只要它开始跳动，整个程序就会持续运行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stopped:</span><br><span class="line">        <span class="comment"># 阻塞, 直到一个事件发生</span></span><br><span class="line">        events = selector.select()</span><br><span class="line">        <span class="keyword">for</span> event_key, event_mask <span class="keyword">in</span> events:</span><br><span class="line">            callback = event_key.data</span><br><span class="line">            callback()</span><br></pre></td></tr></table></figure>

<p>注：总体耗时约0.43秒。</p>
<p>现在<code>loop</code>有了些许变化，<code>callback()</code>不再传递<code>event_key</code>和<code>event_mask</code>参数。也就是说，这里的回调根本不关心是谁触发了这个事件，结合<code>fetch()</code>可以知道，它只需完成对<code>future</code>设置结果值即可<code>f.set_result()</code>。而且<code>future</code>是谁它也不关心，因为<strong>协程</strong>能够保存自己的状态，知道自己的<code>future</code>是哪个。也不用关心到底要设置什么值，因为要设置什么值也是协程内安排的。</p>
<p><strong>此时的<code>loop()</code>，真的成了一个心脏，它只管往外泵血，不论这份血液是要输送给大脑还是要给脚趾，只要它还在跳动，生命就能延续。</strong></p>
<h3 id="生成器协程风格和回调风格对比总结"><a href="#生成器协程风格和回调风格对比总结" class="headerlink" title="生成器协程风格和回调风格对比总结"></a>生成器协程风格和回调风格对比总结</h3><p>在回调风格中：</p>
<ul>
<li>存在链式回调（虽然示例中嵌套回调只有一层）</li>
<li>请求和响应也不得不分为两个回调以至于破坏了同步代码那种结构</li>
<li>程序员必须在回调之间维护必须的状态。</li>
</ul>
<p>还有更多示例中没有展示，但确实存在的问题，参见第3节。</p>
<p>而基于生成器协程的风格：</p>
<ul>
<li>无链式调用</li>
<li><code>selector</code>的回调里只管给<code>future</code>设置值，不再关心业务逻辑</li>
<li><code>loop</code> 内回调<code>callback()</code>不再关注是谁触发了事件</li>
<li>已趋近于同步代码的结构</li>
<li>无需程序员在多个协程之间维护状态，例如哪个才是自己的<code>sock</code></li>
</ul>
<h3 id="碉堡了，但是代码很丑！能不能重构？"><a href="#碉堡了，但是代码很丑！能不能重构？" class="headerlink" title="碉堡了，但是代码很丑！能不能重构？"></a>碉堡了，但是代码很丑！能不能重构？</h3><p>如果说<code>fetch</code>的容错能力要更强，业务功能也需要更完善，怎么办？而且技术处理的部分（socket相关的）和业务处理的部分（请求与返回数据的处理）混在一起。</p>
<ul>
<li>创建<code>socket</code>连接可以抽象复用吧？</li>
<li>循环读取整个<code>response</code>可以抽象复用吧？</li>
<li>循环内处理<code>socket.recv()</code>的可以抽象复用吧？</li>
</ul>
<p>但是这些关键节点的地方都有<code>yield</code>，抽离出来的代码也需要是生成器。而且<code>fetch()</code>自己也得是生成器。生成器里玩生成器，代码好像要写得更丑才可以……</p>
<p>Python 语言的设计者们也认识到了这个问题，再次秉承着“程序猿不必为难程序猿”的原则，他们捣鼓出了一个<code>yield from</code>来解决生成器里玩生成器的问题。</p>
<h2 id="用-yield-from-改进生成器协程"><a href="#用-yield-from-改进生成器协程" class="headerlink" title="用 yield from 改进生成器协程"></a>用 yield from 改进生成器协程</h2><p>yield from 是Python 3.3新引入的语法（PEP380）。它主要解决的就是在生成器里玩生成器不方便的问题。它有两大主要功能。</p>
<p>第一个功能是：让嵌套生成器不必通过循环迭代yield，而是直接yield  from。以下两种在生成器里玩子生成器的方式是等价的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_one</span>():</span></span><br><span class="line">    subgen = range(<span class="number">10</span>)   <span class="comment"># range 惰性求值; 是可迭代对象(__iter__)而不是迭代器(`__iter__`+`__next__`) </span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> subgen</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_two</span>():</span></span><br><span class="line">    subgen = range(<span class="number">10</span>)    </span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> subgen:        </span><br><span class="line">        <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>
<p>第二个功能就是在子生成器和原生成器的调用者之间打开双向通道，两者可以直接通信。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> subgen()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subgen</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">yield</span> x+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    g = gen()</span><br><span class="line">    next(g)                <span class="comment"># 驱动生成器g开始执行到第一个 yield</span></span><br><span class="line">    retval = g.send(<span class="number">1</span>)     <span class="comment"># 看似向生成器 gen() 发送数据</span></span><br><span class="line">    print(retval)          <span class="comment"># 返回2</span></span><br><span class="line">    g.throw(StopIteration) <span class="comment"># 看似向gen()抛入异常</span></span><br></pre></td></tr></table></figure>
<p>通过上述代码清晰地理解了yield from的双向通道功能。关键字yield from在gen()内部为subgen()和main()开辟了通信通道。main()里可以直接将数据1发送给subgen(),subgen()也可以将计算后的数据2返回到main()里，main()里也可以直接向subgen()抛入异常以终止subgen()。</p>
<blockquote>
<p>顺带一提，yield from 除了可以 <code>yield from &lt;generator&gt;</code> 还可以<code> yield from &lt;iterable&gt;</code>。</p>
</blockquote>
<h3 id="yield-from-重构代码"><a href="#yield-from-重构代码" class="headerlink" title="yield from  重构代码"></a>yield from  重构代码</h3><p>抽象socket连接的功能:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span>(<span class="params">sock, address</span>):</span></span><br><span class="line">    f = Future()</span><br><span class="line">    sock.setblocking(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sock.connect(address)</span><br><span class="line">    <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connected</span>():</span></span><br><span class="line">        f.set_result(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    selector.register(sock.fileno(), EVENT_WRITE, on_connected)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> f</span><br><span class="line">    selector.unregister(sock.fileno())</span><br></pre></td></tr></table></figure>

<p>抽象单次<code>recv()</code>和读取完整的response功能:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">sock</span>):</span></span><br><span class="line">    f = Future()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_readable</span>():</span></span><br><span class="line">        f.set_result(sock.recv(<span class="number">4096</span>))</span><br><span class="line"></span><br><span class="line">    selector.register(sock.fileno(), EVENT_READ, on_readable)</span><br><span class="line">    chunk = <span class="keyword">yield</span> <span class="keyword">from</span> f</span><br><span class="line">    selector.unregister(sock.fileno())</span><br><span class="line">    <span class="keyword">return</span> chunk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_all</span>(<span class="params">sock</span>):</span></span><br><span class="line">    response = []</span><br><span class="line">    chunk = <span class="keyword">yield</span> <span class="keyword">from</span> read(sock)</span><br><span class="line">    <span class="keyword">while</span> chunk:</span><br><span class="line">        response.append(chunk)</span><br><span class="line">        chunk = <span class="keyword">yield</span> <span class="keyword">from</span> read(sock)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;&#x27;</span>.join(response)</span><br></pre></td></tr></table></figure>

<p>三个关键点的抽象已经完成，现在重构<code>Crawler</code>类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Crawler</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.response = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetch</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">global</span> stopped</span><br><span class="line">        sock = socket.socket()</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">from</span> connect(sock, (<span class="string">&#x27;example.com&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">        get = <span class="string">&#x27;GET &#123;0&#125; HTTP/1.0\r\nHost: example.com\r\n\r\n&#x27;</span>.format(self.url)</span><br><span class="line">        sock.send(get.encode(<span class="string">&#x27;ascii&#x27;</span>))</span><br><span class="line">        self.response = <span class="keyword">yield</span> <span class="keyword">from</span> read_all(sock)</span><br><span class="line">        urls_todo.remove(self.url)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> urls_todo:</span><br><span class="line">            stopped = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>上面代码整体来讲没什么问题，可复用的代码已经抽象出去，作为子生成器也可以使用 <code>yield from</code> 语法来获取值。但另外有个点需要<strong>注意</strong>：在返回future对象的时候，我们改成了<code>yield from f</code> 而不是原来的<code>yield f</code>。<code>yield</code>可以直接作用于普通Python对象，而<code>yield from</code>却不行，所以我们对<code>Future</code>还要进一步改造，把它变成一个<code>iterable</code>对象就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Future</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.result = <span class="literal">None</span></span><br><span class="line">        self._callbacks = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_done_callback</span>(<span class="params">self, fn</span>):</span></span><br><span class="line">        self._callbacks.append(fn)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span>(<span class="params">self, result</span>):</span></span><br><span class="line">        self.result = result</span><br><span class="line">        <span class="keyword">for</span> fn <span class="keyword">in</span> self._callbacks:</span><br><span class="line">            fn(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> self</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br></pre></td></tr></table></figure>

<p>只是增加了<code>__iter__()</code>方法的实现。如果不把<code>Future</code>改成<code>iterable</code>也是可以的，还是用原来的<code>yield f</code>即可。那为什么需要改进呢？</p>
<p>首先，我们是在基于生成器做协程，而生成器还得是生成器，如果继续混用<code>yield</code>和<code>yield from</code> 做协程，代码可读性和可理解性都不好。其次，如果不改，协程内还得关心它等待的对象是否可被<code>yield</code>，如果协程里还想继续返回协程怎么办？如果想调用普通函数动态生成一个<code>Future</code>对象再返回怎么办？</p>
<p>所以，在Python 3.3 引入<code>yield from</code>新语法之后，就不再推荐用<code>yield</code>去做协程。全都使用<code>yield from</code>由于其双向通道的功能，可以让我们在协程间随心所欲地传递数据。</p>
<h3 id="yield-from改进协程总结"><a href="#yield-from改进协程总结" class="headerlink" title="yield from改进协程总结"></a><code>yield from</code>改进协程总结</h3><p>用yield from改进基于生成器的协程，代码抽象程度更高。使业务逻辑相关的代码更精简。由于其双向通道功能可以让协程之间随心所欲传递数据，使Python异步编程的协程解决方案大大向前迈进了一步。</p>
<p>于是Python语言开发者们充分利用yield from，使 Guido 主导的Python异步编程框架Tulip迅速脱胎换骨，并迫不及待得让它在 Python 3.4 中换了个名字asyncio以“实习生”角色出现在标准库中。</p>
<p>可以参看 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000009781688">yield from 详细解释</a></p>
<h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p>asyncio是Python 3.4 试验性引入的异步I/O框架（PEP 3156），提供了基于协程做异步I/O编写单线程并发代码的基础设施。其核心组件有事件循环（Event Loop）、协程(Coroutine）、任务(Task)、未来对象(Future)以及其他一些扩充和辅助性质的模块。</p>
<p>在引入asyncio的时候，还提供了一个装饰器@asyncio.coroutine用于装饰使用了yield from的函数，以标记其为协程。但并不强制使用这个装饰器。</p>
<p>虽然发展到 Python 3.4 时有了yield from的加持让协程更容易了，但是由于协程在Python中发展的历史包袱所致，很多人仍然弄不明白生成器和协程的联系与区别，也弄不明白yield 和 yield from 的区别。这种混乱的状态也违背Python之禅的一些准则。</p>
<p>于是Python设计者们又快马加鞭地在 3.5 中新增了async/await语法（PEP 492），对协程有了明确而显式的支持，称之为原生协程。async/await 和 yield from这两种风格的协程底层复用共同的实现，而且相互兼容。</p>
<p>在Python 3.6 中asyncio库“转正”，不再是实验性质的，成为标准库的正式一员。</p>
<p>行至此处，我们已经掌握了asyncio的核心原理，学习了它的原型，也学习了异步I/O在 CPython 官方支持的生态下是如何一步步发展至今的。</p>
<p>实际上，真正的asyncio比我们前几节中学到的要复杂得多，它还实现了零拷贝、公平调度、异常处理、任务状态管理等等使 Python 异步编程更完善的内容。理解原理和原型对我们后续学习有莫大的帮助。</p>
<h2 id="await-async"><a href="#await-async" class="headerlink" title="await/async"></a>await/async</h2><p>本节中，我们将初步体验asyncio库和新增语法async/await给我们带来的便利。由于Python2-3的过度期间，Python3.0-3.4的使用者并不是太多，也为了不让更多的人困惑，也因为aysncio在3.6才转正，所以更深入学习asyncio库的时候我们将使用async/await定义的原生协程风格，yield from风格的协程不再阐述（实际上它们可用很小的代价相互代替）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line"></span><br><span class="line">host &#x3D; &#39;http:&#x2F;&#x2F;example.com&#39;</span><br><span class="line">urls_todo &#x3D; &#123;&#39;&#x2F;&#39;, &#39;&#x2F;1&#39;, &#39;&#x2F;2&#39;, &#39;&#x2F;3&#39;, &#39;&#x2F;4&#39;, &#39;&#x2F;5&#39;, &#39;&#x2F;6&#39;, &#39;&#x2F;7&#39;, &#39;&#x2F;8&#39;, &#39;&#x2F;9&#39;&#125;</span><br><span class="line"></span><br><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def fetch(url):</span><br><span class="line">    async with aiohttp.ClientSession(loop&#x3D;loop) as session:</span><br><span class="line">        async with session.get(url) as response:</span><br><span class="line">            response &#x3D; await response.read()</span><br><span class="line">            return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    import time</span><br><span class="line">    start &#x3D; time.time()</span><br><span class="line">    tasks &#x3D; [fetch(host + url) for url in urls_todo]</span><br><span class="line">    loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line">    print(time.time() - start)</span><br></pre></td></tr></table></figure>
<p>对比生成器版的协程，使用asyncio库后变化很大：</p>
<ul>
<li>没有了yield 或 yield from，而是async/await</li>
<li>没有了自造的loop()，取而代之的是asyncio.get_event_loop()</li>
<li>无需自己在socket上做异步操作，不用显式地注册和注销事件，aiohttp库已经代劳</li>
<li>没有了显式的 Future 和 Task，asyncio已封装</li>
<li>更少量的代码，更优雅的设计</li>
</ul>
<blockquote>
<p>说明：我们这里发送和接收HTTP请求不再自己操作socket的原因是，在实际做业务项目的过程中，要处理妥善地HTTP协议会很复杂，我们需要的是功能完善的异步HTTP客户端，业界已经有了成熟的解决方案，DRY不是吗？</p>
</blockquote>
<p>和同步阻塞版的代码对比：</p>
<ul>
<li>异步化</li>
<li>代码量相当（引入aiohttp框架后更少）</li>
<li>代码逻辑同样简单，跟同步代码一样的结构、一样的逻辑</li>
<li>接近10倍的性能提升</li>
</ul>
<p>生成器与asyncio提供的新版语法的区别请参看： <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/032ad0848f6b">async/await详解</a></p>
<p>到此为止，我们已经深入地学习了异步编程<strong>是什么、为什么、在Python里是怎么样发展的</strong>。我们找到了一种让代码看起来跟同步代码一样简单，而效率却提升N倍（具体提升情况取决于项目规模、网络环境、实现细节）的异步编程方法。它也没有回调的那些缺点。</p>
<h1 id="python-web中的异步"><a href="#python-web中的异步" class="headerlink" title="python web中的异步"></a>python web中的异步</h1><p>经过以上对异步编程的学习，接下来我们要把这些异步运用到python web中。</p>
<p>在python web编程中，有很多流行的框架，大体分为2类：wsgi、asgi.</p>
<h2 id="WSGI-ASGI"><a href="#WSGI-ASGI" class="headerlink" title="WSGI/ASGI"></a>WSGI/ASGI</h2><p>这里需要特别解释一下几个名词：<br>wsgi server (比如uWSGI/gunicorn） 要和 wsgi   application（比如django/flask）交互，uwsgi需要将过来的请求转给django 处理，那么uWSGI 和 django的交互和调用就需要一个统一的规范，这个规范就是WSGI（Web Server Gateway Interface）</p>
<p>asgi与wsgi的区别之处就在于，asgi扩展了wsgi,可以支持WebSocket，具有异步功能。</p>
<ul>
<li><p>wsgi application有以下代表：</p>
<ol>
<li>Django</li>
<li>flask</li>
<li>bottle</li>
<li>webpy</li>
<li>CherryPy</li>
<li>web2py</li>
</ol>
</li>
<li><p>wsgi server有以下代表：</p>
<ol>
<li>uWSGI</li>
<li>gunicorn</li>
</ol>
</li>
<li><p>asgi application有以下代表</p>
<ol>
<li>Starlette（需要使用ASGI服务作为容器，比如Uvicorn）</li>
<li>Django Channels</li>
<li>FastAPI(集成Starlette)</li>
<li>tornado</li>
<li>Snaic</li>
<li>Quart</li>
<li>twisted</li>
<li>APIStar</li>
</ol>
</li>
<li><p>asgi server有以下代表</p>
<ol>
<li>uvicorn </li>
</ol>
</li>
</ul>
<p>那么如果已经是wsgi的同步框架能不能无缝转成异步呢？no problem —&gt; greenlet/gevent</p>
<p>我们已经知道，要异步，<strong>事件循环+回调</strong> 跑不掉。那么这个事件循环+回调在uvicorn的中只怎么体现的呢？</p>
<p><code>myapp.py</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    uvicorn.run(app&#x3D;&#39;myapp.main:app&#39;)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uvicorn/mainpy</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Server:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def run(self, sockets&#x3D;None):</span><br><span class="line">        self.config.setup_event_loop()</span><br><span class="line">        loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">        loop.run_until_complete(self.serve(sockets&#x3D;sockets))</span><br><span class="line">        </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>可以看到<code>asyncio.get_event_loop()</code>获取时间循环，然后把封装了sock的serve（其实就是future对象）放入事件循环处理。</p>
<p>uvicorn 支持的loop有3种，auto/asyncio/uvloop, 默认是auto. auto会尝试首先<strong>加载uvloop</strong>,加载失败才会加载asyncio的loop.</p>
<blockquote>
<p>值得一说的是，可以使用uvicorn + gunicorn部署python asgi服务。uvicorn实现了gunicorn的worker接口，所以gunicorn启动服务的时候可以指定使用uvicorn的worker，比如：<code>gunicorn -k uvicorn.workers.UvicornWorker</code></p>
</blockquote>
<h2 id="python-web中的io阻塞"><a href="#python-web中的io阻塞" class="headerlink" title="python web中的io阻塞"></a>python web中的io阻塞</h2><p>web项目最常见的就是 CRUD操作。在这类操作中一般出现的io阻塞场景为：</p>
<ol>
<li>restful API基于网络，http是基于tcp的可靠传输协议，建立/断开连接的过程也是耗时的io操作。</li>
<li>数据库的连接是网络连接或套接字文件读写类的链接，也是io耗时的。</li>
<li>数据库/缓存的增删改查操作，这一步主要是数据库/缓存的io，是io耗时的。</li>
<li>数据的处理，比如数据库数据和model对象的转化等，主要是ORM，需要进行内存读写，是io耗时的。</li>
</ol>
<p>针对以上场景的处理方法是：</p>
<ol>
<li>restful API请求的处理，主要依靠asgi/wsgi server来处理，asgi server支持异步的方式让出io，提高web应用的响应速度</li>
<li>数据库连接和数据库的增删改查当然也有异步io的数据库driver可以支持，比如：SQLAlchemy1.4版本及以上/peewee/python databases等</li>
<li>缓存以redis为例，可以使用aioredis来支持异步io</li>
<li>orm 处理可以如第二条的SQLAlchemy1.4和peewee等</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIxMjY5NTE0MA==&mid=2247483720&idx=1&sn=f016c06ddd17765fd50b705fed64429c">深入理解Python异步编程</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/64991670">小白的 asyncio ：原理、源码 到实现</a></li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="琢灵 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>琢灵
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://xiaobinzhao.github.io/2020/10/20/python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" title="python异步编程">https://xiaobinzhao.github.io/2020/10/20/python异步编程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"><i class="fa fa-tag"></i> python</a>
              <a href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 异步编程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/19/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" rel="prev" title="缓存穿透，缓存击穿，缓存雪崩">
      <i class="fa fa-chevron-left"></i> 缓存穿透，缓存击穿，缓存雪崩
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/20/%E5%B9%B6%E5%8F%91%E5%92%8C%E9%94%81/" rel="next" title="并发和锁">
      并发和锁 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">什么是异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E"><span class="nav-number">1.1.</span> <span class="nav-text">阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-number">1.2.</span> <span class="nav-text">非阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-number">1.3.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C"><span class="nav-number">1.4.</span> <span class="nav-text">并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.</span> <span class="nav-text">概念总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">异步编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E4%B9%8B%E9%9A%BE-nan"><span class="nav-number">1.7.</span> <span class="nav-text">异步之难(nán)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">为什么要异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU%E7%9A%84%E6%97%B6%E9%97%B4%E8%A7%82"><span class="nav-number">2.1.</span> <span class="nav-text">CPU的时间观</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.</span> <span class="nav-text">面临的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">2.3.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python%E6%80%8E%E4%B9%88%E5%81%9A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">python怎么做异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF"><span class="nav-number">3.1.</span> <span class="nav-text">异步进化之路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.1.</span> <span class="nav-text">同步阻塞方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E8%BF%9B%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.1.2.</span> <span class="nav-text">改进方式：多进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E7%BB%AD%E6%94%B9%E8%BF%9B%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.1.3.</span> <span class="nav-text">继续改进：多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.4.</span> <span class="nav-text">非阻塞方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%94%B9%E8%BF%9B"><span class="nav-number">3.1.5.</span> <span class="nav-text">非阻塞改进</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83-Callback"><span class="nav-number">3.1.5.2.</span> <span class="nav-text">回调(Callback)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89"><span class="nav-number">3.1.5.3.</span> <span class="nav-text">事件循环（Event Loop）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%80%BB%E7%BB%93"><span class="nav-number">3.1.5.4.</span> <span class="nav-text">非阻塞总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.</span> <span class="nav-text">python的异步实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E4%B9%8B%E7%97%9B%EF%BC%8C%E4%BB%A5%E7%BB%88%E4%B8%BA%E5%A7%8B"><span class="nav-number">3.2.1.</span> <span class="nav-text">回调之痛，以终为始</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">核心问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">协程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%8D%8F%E7%A8%8B%EF%BC%88yield%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">基于生成器的协程（yield）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AA%E6%9D%A5%E5%AF%B9%E8%B1%A1-Future"><span class="nav-number">5.1.1.</span> <span class="nav-text">未来对象(Future)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84-Crawler"><span class="nav-number">5.1.2.</span> <span class="nav-text">重构 Crawler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%AF%B9%E8%B1%A1-Task"><span class="nav-number">5.1.3.</span> <span class="nav-text">任务对象(Task)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop-%E9%A9%B1%E5%8A%A8%E5%8D%8F%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="nav-number">5.1.4.</span> <span class="nav-text">事件循环(Event Loop)驱动协程运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%8D%8F%E7%A8%8B%E9%A3%8E%E6%A0%BC%E5%92%8C%E5%9B%9E%E8%B0%83%E9%A3%8E%E6%A0%BC%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="nav-number">5.1.5.</span> <span class="nav-text">生成器协程风格和回调风格对比总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A2%89%E5%A0%A1%E4%BA%86%EF%BC%8C%E4%BD%86%E6%98%AF%E4%BB%A3%E7%A0%81%E5%BE%88%E4%B8%91%EF%BC%81%E8%83%BD%E4%B8%8D%E8%83%BD%E9%87%8D%E6%9E%84%EF%BC%9F"><span class="nav-number">5.1.6.</span> <span class="nav-text">碉堡了，但是代码很丑！能不能重构？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8-yield-from-%E6%94%B9%E8%BF%9B%E7%94%9F%E6%88%90%E5%99%A8%E5%8D%8F%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">用 yield from 改进生成器协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#yield-from-%E9%87%8D%E6%9E%84%E4%BB%A3%E7%A0%81"><span class="nav-number">5.2.1.</span> <span class="nav-text">yield from  重构代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield-from%E6%94%B9%E8%BF%9B%E5%8D%8F%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="nav-number">5.2.2.</span> <span class="nav-text">yield from改进协程总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#asyncio"><span class="nav-number">5.3.</span> <span class="nav-text">asyncio</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#await-async"><span class="nav-number">5.4.</span> <span class="nav-text">await&#x2F;async</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#python-web%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5"><span class="nav-number">6.</span> <span class="nav-text">python web中的异步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WSGI-ASGI"><span class="nav-number">6.1.</span> <span class="nav-text">WSGI&#x2F;ASGI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python-web%E4%B8%AD%E7%9A%84io%E9%98%BB%E5%A1%9E"><span class="nav-number">6.2.</span> <span class="nav-text">python web中的io阻塞</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">7.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="琢灵"
      src="/images/my-avatar.jpg">
  <p class="site-author-name" itemprop="name">琢灵</p>
  <div class="site-description" itemprop="description">技术笔记，生活点滴</div>
</div>


   <div class="feed-link motion-element">
     <a href="/atom.xml" rel="alternate">
       <i class="fa fa-rss"></i>
       RSS
     </a>
   </div>
 
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/XiaobinZhao" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;XiaobinZhao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

      
        <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
        <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
        <div class="widget-wrap">
            <div id="myCanvasContainer" class="widget tagcloud">
                <canvas width="250" height="250" id="resCanvas" style="width:100%">
                    <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/169-254-169-254/" rel="tag">169.254.169.254</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConfigDrive/" rel="tag">ConfigDrive</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Coroutine/" rel="tag">Coroutine</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FastAPI/" rel="tag">FastAPI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GoFrame/" rel="tag">GoFrame</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO%E6%A8%A1%E5%9E%8B/" rel="tag">IO模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KanBan/" rel="tag">KanBan</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Machine-Type/" rel="tag">Machine Type</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Next/" rel="tag">Next</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PostgreSQL/" rel="tag">PostgreSQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RMM/" rel="tag">RMM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Richardson%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B/" rel="tag">Richardson成熟度模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ScrumBan/" rel="tag">ScrumBan</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VDI/" rel="tag">VDI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/agile/" rel="tag">agile</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cap/" rel="tag">cap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cloud-init/" rel="tag">cloud-init</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cloudbase-init/" rel="tag">cloudbase-init</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/db/" rel="tag">db</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deb/" rel="tag">deb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/depends/" rel="tag">depends</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etag/" rel="tag">etag</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/etcd-lock/" rel="tag">etcd lock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fcntl/" rel="tag">fcntl</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gf/" rel="tag">gf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql-%E4%B9%90%E8%A7%82%E9%94%81/" rel="tag">mysql 乐观锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql-%E6%82%B2%E8%A7%82%E9%94%81/" rel="tag">mysql 悲观锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/oslo-concurrency/" rel="tag">oslo.concurrency</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/psql/" rel="tag">psql</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/qemu/" rel="tag">qemu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis-lock/" rel="tag">redis lock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scrum/" rel="tag">scrum</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spice/" rel="tag">spice</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vnc/" rel="tag">vnc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/yield/" rel="tag">yield</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/" rel="tag">云计算</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="tag">分布式锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag">协程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8C%E6%AD%A5/" rel="tag">同步</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F/" rel="tag">大小写敏感</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" rel="tag">异步编程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/" rel="tag">敏捷开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E9%94%81/" rel="tag">文件锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/" rel="tag">缓存击穿</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" rel="tag">缓存穿透</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" rel="tag">缓存雪崩</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" rel="tag">虚拟化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%81%97%E7%95%99%E7%B3%BB%E7%BB%9F%E6%94%B9%E9%80%A0/" rel="tag">遗留系统改造</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%BB%E5%A1%9E/" rel="tag">阻塞</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E/" rel="tag">非阻塞</a><span class="tag-list-count">1</span></li></ul>
                </canvas>
            </div>
        </div>
      

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.gov.cn/" rel="noopener" target="_blank">陕ICP备2021002750号 </a>
      <img src="/images/beian.png" style="display: inline-block;">
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">琢灵</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>


  <script src='https://unpkg.com/mermaid@8.8.4/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({});
    }
  </script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'IhFe1C45bDBFTjSxcahEd1Lv-gzGzoHsz',
      appKey     : 'Ljdc8IPrTgT76N2glnDMs90o',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
